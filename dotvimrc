" Author: Wang Zhen

" vundle 设置 {{{1
" ===================================
filetype off                   " required!
let g:vundle_default_git_proto = 'git'

set rtp+=~/.vim_bundle/vundle
set rtp+=~/.vim_bundle/gocode/vim
if $GOROOT != ''
    set rtp+=$GOROOT/misc/vim
endif
set rtp+=~/.vim_bundle/powerline/powerline/bindings/vim
call vundle#rc('~/.vim_bundle')

" let Vundle manage Vundle
" required!
Bundle 'gmarik/vundle'

if filereadable(expand("~/.vim/bundles.vim"))
    source ~/.vim/bundles.vim
endif
filetype plugin indent on
syntax enable
syntax on
" }}}1

" 颜色相关设置 {{{1
" ===================================
if &term =~ "xterm\\|screen"
    " 256 color
    set t_Co=256
    set t_AB=[48;5;%dm
    set t_AF=[38;5;%dm
endif
" 主题设置 {{{2
if has("gui_running")
    set background=dark
    let g:solarized_termtrans=1
    let g:solarized_termcolors=256
    let g:solarized_contrast="high"
    let g:solarized_visibility="high"
    silent! colorscheme solarized
elseif &t_Co == 256
    set background=dark
    let g:solarized_termtrans=1
    let g:solarized_termcolors=256
    let g:solarized_contrast="high"
    let g:solarized_visibility="high"
    "silent! colorscheme solarized
    "silent! colorscheme desertEx
    let g:rehash256=1
    silent! colorscheme molokai
end
" hi设置 {{{2
hi diffAdded ctermfg=31 guifg=#268bd2
hi diffRemoved ctermfg=161 guifg=#d30102
"hi cursorline term=standout,bold cterm=bold ctermfg=None ctermbg=23 gui=bold " 高亮光标所在行
"hi Normal ctermbg=None
hi ToDo cterm=bold ctermfg=9 ctermbg=226 gui=standout guibg=#eeee00 guifg=#ff4500

" 自动补全弹出菜单颜色设置
hi Pmenu term=standout cterm=none ctermfg=0 ctermbg=250 guifg=#000000 guibg=#bcbcbc
hi PmenuSel cterm=bold ctermfg=234 ctermbg=174 gui=bold guifg=bg guibg=#df8787
hi PMenuSbar guifg=#ededed guibg=#202020 guisp=#202020 gui=NONE ctermfg=255 ctermbg=255 cterm=NONE
hi PMenuThumb guifg=#dbdbdb guibg=#303030 guisp=#303030 gui=NONE ctermfg=253 ctermbg=35 cterm=NONE

" 高亮特殊字符
hi SpecialKey guifg=#808080 guibg=#343434 guisp=#343434 gui=NONE ctermfg=8 ctermbg=236 cterm=NONE

"hi WildMenu term=standout cterm=standout ctermfg=95 ctermbg=230 guifg=gray guibg=gray17

hi cMathOperator            cterm=bold ctermfg=6 guifg=#3EFFE2
hi cPointerOperator         cterm=bold ctermfg=6 guifg=#3EFFE2
hi cLogicalOperator         cterm=bold ctermfg=6 guifg=#3EFFE2
hi cBinaryOperator          cterm=bold ctermfg=6 guifg=#3EFFE2
hi cBinaryOperatorError     cterm=bold ctermfg=6 guifg=#3EFFE2
hi cLogicalOperator         cterm=bold ctermfg=6 guifg=#3EFFE2
hi cLogicalOperatorError    cterm=bold ctermfg=6 guifg=#3EFFE2
"hi cFunction                term=underline cterm=bold ctermfg=148 guifg=skyblue
hi! link cFunction Function
hi PreCondit cterm=bold ctermfg=160

" 高亮行尾的空格
"au BufEnter,InsertEnter,InsertLeave * 2match WhitespaceEOL /\s\+$/
"highlight WhitespaceEOL ctermbg=red guibg=red

" Highlight VCS conflict markers
au BufEnter,InsertEnter,InsertLeave * 3match ErrorMsg /^\(<\|=\|>\)\{7\}\([^=].\+\)\?$/

" }}}1

" set相关 {{{1
" ===================================
" 一般设置 {{{2
set nocompatible
" allow backspacing over everything in insert mode
set backspace=indent,eol,start
if has("vms")
    set nobackup      " do not keep a backup file, use versions instead
else
    set backup        " keep a backup file
endif
set ruler           " show the cursor position all the time
set ttyfast         " smoother changes
set showcmd         " display incomplete commands
set incsearch       " do incremental searching
set ignorecase
set smartcase       " 当搜索字符中包含大写字母时，大小写敏感
set sw=4            " shiftwidth
set et              " expandtab
set nu              " show line number
set wm=4            " wrapmargin
set ts=4            " tabstop
set smarttab        " smarttab
set softtabstop=4
set matchpairs+=<:> " show matching <> as well
set updatetime=1000
set hidden          " allow buffers to go into the background without needing to save
set mouse=a         " In many terminal emulators the mouse works just fine, thus enable it.

if exists('$TMUX')
    set ttymouse=xterm2
endif

set fileformat=unix
set fileformats=unix,dos,mac
set nopaste
set smartindent
set title " change the terminal's title
set wildmenu
"set wildmode=longest:full,full
set wildmode=longest,list,full
set autowrite
set hlsearch
set ai              " autoindent
set si              " smartindent
set tags=tags;/
set nowrap
set so=7            " Set 7 lines to curors - when moving vertical..
set fdm=marker
auto FileType c,cpp,python set fdm=syntax
auto FileType diff set fdm=diff
set foldlevelstart=999
set laststatus=2
set pastetoggle=<F3>
set report=0
set cursorline      " 高亮当前行
"set cuc             " 高亮当前列
set wildignore+=*.o,*.obj
set wildignore+=*~,*.sw?
set wildignore+=.git,.svn,CVS,.hg
set infercase
set display=lastline " when a line is long, don't omit it in @

set history=500
set undolevels=1000
if v:version >= 703
    set undofile
    set undodir=~/.vim_tmp
endif

set completeopt=menu,menuone,longest

autocmd FileType c,cpp,python,sh set list
set listchars=tab:\|-,extends:>,nbsp:.,precedes:<,trail:~
"▋,eol:¶
"
autocmd FileType text setlocal textwidth=78 " For all text files set 'textwidth' to 78 characters.

" 打开文件时自动跳到上次退出时光标所在位置
autocmd BufReadPost *
            \ if line("'\"") > 0 && line("'\"") <= line("$") |
            \   exe "normal! g`\"" |
            \ endif

"autocmd BufEnter * lcd %:p:h " 自动切换到当前文件所在目录

" automatically rebalance windows on vim resize
autocmd VimResized * :wincmd =

" Convenient command to see the difference between the current buffer and the file it was loaded from, thus the changes you made.
command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
            \ | wincmd p | diffthis

:runtime! ftplugin/man.vim " :Man 3 printf
" 编码设置 {{{2
let &termencoding=&encoding
" vim解析文件时尝试的编码格式顺序列表
set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr
set encoding=utf-8  " vim内部使用的字符编码格式
set fileencoding=utf-8  " vim识别出来的文件的编码格式
"set termencoding=utf-8

" map leader {{{2
let g:C_MapLeader=','
let C_MapLeader=','
let mapleader=','
let g:mapleader=','

" map {{{2
nnoremap ; :
nnoremap <Leader>; ;
nnoremap <Leader>q :q<CR>

"nnoremap j gj
"nnoremap k gk
cmap w!! w !sudo tee % >/dev/null<CR>:e!<CR><CR>

" delete trailing whitespaces
nmap <silent><Leader>et :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar>:nohl<CR>

" Quick alignment of text
nnoremap <Leader>al :left<CR>
nnoremap <Leader>ar :right<CR>
nnoremap <Leader>ac :center<CR>

" Conflict markers {{{2
" highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'
" shortcut to jump to next conflict marker
nnoremap <silent> <leader>k /^\(<\\|=\\|>\)\{7\}\([^=].\+\)\?$<CR>

nmap <silent> <leader>df :DiffOrig<cr>

" use ,n to turn off highlighting
nmap <silent> <leader>n :silent noh<CR>
nmap <silent> <leader>rr :redraw!<cr> " Fast redraw

" Smart way to move btw. windows
"nmap <C-j> <C-W>j
"nmap <C-k> <C-W>k
"nmap <C-h> <C-W>h
"nmap <C-l> <C-W>l

map Q gq            " Don't use Ex mode, use Q for formatting

au BufNewFile,BufRead *.json set ft=json

" C/C++ 相关设置 {{{2
set cinoptions=:0,g0,l1,(0,w0,W4,t0,N-s
autocmd BufNewFile *.c 0r ~/.vim/templates/main.c
autocmd BufNewFile *.go 0r ~/.vim/templates/main.go
autocmd BufNewFile *.{cpp,cc} 0r ~/.vim/templates/main.cpp
autocmd BufNewFile *.{h,hpp} call <SID>insert_include_guard() " C/C++ include guard

" c/c++ include guard {{{3
function! s:insert_include_guard()
    let guard_name = substitute(toupper(expand("%:t")), "\\-\\|\\.", "_", "g") . '_' . "INCLUDED__"
    execute "normal! i#ifndef " . guard_name
    execute "normal! o#define " . guard_name
    execute "normal! o\n<+TYPE HERE+>\n"
    execute "normal! Go#endif /* " . guard_name . " */"
    normal! kk
endfunction

" python 相关设置 {{{2
autocmd BufNewFile *.py 0r ~/.vim/templates/main.py
au FileType python setlocal foldmethod=indent
let python_highlight_all = 1

" shell {{{2
autocmd BufNewFile *.sh 0r ~/.vim/templates/main.sh

" quickfix {{{2
au QuickfixCmdPost make call QfMakeConv() " 编码转换
" 在有错误时自动打开quickfix窗口
"au QuickFixCmdPost [^l]* nested cwindow
"au QuickFixCmdPost l* nested cwindow
" QfMakeConv {{{3
function! QfMakeConv()
    let qflist = getqflist()
    for i in qflist
        let i.text = iconv(i.text, "C", "utf-8")
    endfor
    call setqflist(qflist)
endfunction
nmap <F6> :cn <cr>
nmap <F7> :cp <cr>
nmap <leader>cn :cn<cr>
nmap <leader>cp :cp<cr>
nmap <leader>cw :cw 10<cr>

" cscope {{{2

if has("cscope")
    "set csprg=/usr/local/bin/cscope
    set csto=0
    set cst
    set nocsverb
    " add any database in current directory
    if filereadable("cscope.out")
        cs add cscope.out
        " else add database pointed to by environment
    elseif $CSCOPE_DB != ""
        cs add $CSCOPE_DB
    endif
    set csverb
endif

set cscopequickfix=s-,c-,d-,i-,t-,e-
map <F12> :call Do_CsTag()<CR>
nmap <leader>sfs :cs find s <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <leader>sfg :cs find g <C-R>=expand("<cword>")<CR><CR>
nmap <leader>sfc :cs find c <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <leader>sft :cs find t <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <leader>sfe :cs find e <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <leader>sff :cs find f <C-R>=expand("<cfile>")<CR><CR>:copen<CR>
nmap <leader>sfi :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>:copen<CR>
nmap <leader>sfd :cs find d <C-R>=expand("<cword>")<CR><CR>:copen<CR>
" Do_CsTag {{{3
function! Do_CsTag()
    let dir = getcwd()
    if filereadable("tags")
        let tagsdeleted=delete("./"."tags")
        if(tagsdeleted!=0)
            echohl WarningMsg | echo "Fail to do tags! I cannot delete the tags" | echohl None
            return
        endif
    endif
    if has("cscope")
        silent! execute "cs kill -1"
    endif
    if filereadable("cscope.files")
        let csfilesdeleted=delete("./"."cscope.files")
        if(csfilesdeleted!=0)
            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.files" | echohl None
            return
        endif
    endif
    if filereadable("cscope.out")
        let csoutdeleted=delete("./"."cscope.out")
        if(csoutdeleted!=0)
            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.out" | echohl None
            return
        endif
    endif
    if(executable('ctags'))
        "silent! execute "!ctags -R --c-types=+p --fields=+S *"
        "silent! execute "!ctags -R --c++-kinds=+pl --fields=+iaS --extra=+q ."
        silent! execute "!ctags -R --sort=yes --c++-kinds=+plx --fields=+iaS --extra=+q ."
    endif
    if(executable('cscope') && has("cscope") )
        silent! execute "!find . -name '*.h' -o -name '*.c' -o -name '*.cpp' -o -name '*.java' -o -name '*.cs' > cscope.files"
        silent! execute "!cscope -b"
        execute "normal :"
        if filereadable("cscope.out")
            execute "cs add cscope.out"
        endif
    endif
endfunction
" }}}1

" 插件设置 {{{1
" ===================================
" winManager {{{2
let g:winManagerWindowLayout="NERDTree|BufExplorer"
let g:defaultExplorer = 0
let g:winManagerWidth=30
"nmap wm :WMToggle<cr>
nmap wm :if IsWinManagerVisible() <BAR> WMToggle<CR> <BAR> else <BAR> WMToggle<CR>:q<CR> endif <CR><CR>

" NERDTree {{{2
"Used by winmanager
let g:NERDTree_title = "[NERDTree]"

function! NERDTree_Start()
    exec 'NERDTree'
endfunction

function! NERDTree_IsValid()
    return 1
endfunction

let NERDTreeShowBookmarks=1
let NERDTreeIgnore=['\.pyc', '\~$', '\.swo$', '\.swp$', '\.git', '\.hg', '\.svn', '\.bzr', 'CVS']
let NERDTreeChDirMode=0
"let NERDTreeQuitOnOpen=1
let NERDTreeShowHidden=1
let NERDTreeHightCursorline=1
"let NerdTreeShowLineNumbers=1
let NERDTreeStatusline=1
let NERDTreeDirArrows=0
let NERDTreeShowBookmarks=1
let NERDChristmasTree=1
"let NERDTreeKeepTreeInNewTab=1

" BufExplorer {{{2
let g:bufExplorerDefaultHelp=0       " show default help or not
let g:bufExplorerDetailedHelp=0      " Show detailed help.
let g:bufExplorerShowRelativePath=1  " Show relative paths.
let g:bufExplorerSortBy='mru'        " Sort by most recently used.
let g:bufExplorerSplitRight=0        " Split left.
let g:bufExplorerSplitVertical=1     " Split vertically.
let g:bufExplorerSplitVertSize = 30  " Split width
let g:bufExplorerUseCurrentWindow=1  " Open in new window.
let g:bufExplorerMaxHeight=25        " Max height
let g:bufExplorerMinHeight=25        " Max height
autocmd BufWinEnter \[Buf\ List\] setl nonumber

" Tagbar {{{2
nmap tg :TagbarToggle<cr>
" open Tabbar automatically on Vim startup only if opening Vim with a supported file/files
"autocmd VimEnter * nested :call tagbar#autoopen()
let g:tagbar_auto_showtag=1
"let g:tagbar_autofocus=1
let g:tagbar_usearrows=1
let g:tagbar_sort=0
"let g:tagbar_ctags_bin='/usr/bin/ctags'
" support gotags
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
\ }

" clang_complete {{{2
let g:clang_auto_select=0
let g:clang_complete_auto=0
let g:clang_complete_copen=1
let g:clang_hl_errors=1
let g:clang_periodic_quickfix=0
let g:clang_snippets=1
let g:clang_snippets_engine="clang_complete"
let g:clang_close_preview=1
let g:clang_trailing_placeholder=0
"let g:clang_exec="clang"
let g:clang_user_options="-std=c++11"
let g:clang_use_library=1
let g:clang_library_path="/usr/local/lib"
let g:clang_complete_macros=1
let g:clang_complete_patterns=1
let g:clang_auto_user_options="path, .clang_complete, compile_commands.json"

if has('conceal')
    let g:clang_conceal_snippets=1
endif

" TaskList {{{2
map <leader>td :TaskList<CR>

" Gundo {{{2
map <leader>gu :GundoToggle<CR>

" csupport {{{2
" csupport templates path
let g:C_LocalTemplateFile=$HOME."/.vim/templates/Templates"

" python-mode {{{2
let g:pymode_lint_checker = "pyflakes"
let g:pymode_rope_guess_project = 0
let g:pymode_rope=0

" neocomplete {{{2
let g:neocomplete#disable_auto_complete=0
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#enable_fuzzy_completion = 1
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#auto_completion_start_length = 2
let g:neocomplete#manual_completion_start_length = 0
let g:neocomplete#min_keyword_length = 3
let g:neocomplete#enable_cursor_hold_i = 0
let g:neocomplete#cursor_hold_i_time = 300
let g:neocomplete#enable_insert_char_pre = 0
let g:neocomplete#enable_prefetch = 0
let g:neocomplete#skip_auto_completion_time='0.6'
let g:neocomplete#enable_auto_delimiter = 0
let g:neocomplete#data_directory = '~/.vim_tmp/.neocon'
let g:neocomplete#max_list = 100
let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
let g:neocomplete#enable_auto_close_preview = 1
let g:neocomplete#enable_complete_select = 0
let g:neocomplete#enable_auto_select = 1
let g:neocomplete#enable_refresh_always = 1
let g:neocomplete#diable_auto_select_buffer_name_pattern = '\[Command Line\]'

if g:neocomplete#enable_complete_select
    set completeopt-=noselect
    set completeopt+=noinsert
endif

" Define Dictionary
" need to run :NeoCompleteDictionaryMakeCache c
" and :NeoCompleteDictionaryMakeCache cpp
let g:neocomplete#sources#dictionary#dictionaries = {
            \'default':'',
            \'cpp':'~/.vim_bundle/c.vim/c-support/wordlists/c-c++-keywords.list,
            \~/.vim_bundle/c.vim/c-support/wordlists/k+r.list,
            \~/.vim_bundle/c.vim/c-support/wordlists/stl_index.list',
            \'c':'~/.vim_bundle/c.vim/c-support/wordlists/c-c++-keywords.list,
            \~/.vim_bundle/c.vim/c-support/wordlists/k+r.list,
            \~/.vim_bundle/c.vim/c-support/wordlists/stl_index.list'}

let g:neocomplete#force_overwrite_completefunc = 1

if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
endif
if !exists('g:neocomplete#sources#omni#functions')
    let g:neocomplete#sources#omni#functions = {}
endif
if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
endif

let g:neocomplete#sources#omni#input_patterns.ruby = '[^. *\t]\.\w*\|\h\w*::\w*'
let g:neocomplete#sources#omni#input_patterns.php =
            \ '[^. \t]->\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'
let g:neocomplete#sources#omni#input_patterns.c =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?'
let g:neocomplete#sources#omni#input_patterns.cpp =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\%(\h\w*\)\?\|\h\w*::\%(\h\w*\)\?'

let g:neocomplete#force_omni_input_patterns.c =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
let g:neocomplete#force_omni_input_patterns.cpp =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
let g:neocomplete#force_omni_input_patterns.objc =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
let g:neocomplete#force_omni_input_patterns.objcpp =
            \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'

if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
endif

let g:neocomplete#keyword_patterns._ = '[0-9a-zA-Z:#_]\+'

call neocomplete#custom#source('look', 'min_pattern_length', 4)

" Enable omni completion
if has('python3')
    au FileType python setlocal omnifunc=python3complete#Complete
else
    au FileType python setlocal omnifunc=pythoncomplete#Complete
endif

autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType ruby setlocal omnifunc=rubycomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

let g:neocomplete#sources#omni#functions.go = 'gocomplete#Complete'

let g:neocomplete#sources#tags#cache_limit_size = 500000

" For snippet_complete marker.
if has('conceal')
    set conceallevel=2 concealcursor=i
endif

" key maps {{{3
inoremap <expr><C-g> neocomplete#undo_completion()
inoremap <expr><C-l> neocomplete#complete_common_string()

" <C-f>, <C-b>: page move.
inoremap <expr><C-f> pumvisible() ? "\<PageDown>" : "\<Right>"
inoremap <expr><C-b> pumvisible() ? "\<PageUp>" : "\<Left>"

" paste
inoremap <expr><C-y> pumvisible() ? neocomplete#close_popup() : "\<C-r>\""
" close popup
inoremap <expr><C-e> pumvisible() ? neocomplete#cancel_popup() : "\<End>"

let g:neosnippet#enable_snipmate_compatibility = 1
let g:neosnippet#snippets_directory = '~/.vim_bundle/vim-snippets/snippets'

imap <C-k>     <Plug>(neosnippet_expand_or_jump)
smap <C-k>     <Plug>(neosnippet_expand_or_jump)
xmap <C-k>     <Plug>(neosnippet_expand_target)

" SuperTab like snippets behavior.
imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
            \ "\<Plug>(neosnippet_expand_or_jump)"
            \: pumvisible() ? "\<C-n>" : "\<TAB>"
smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
            \ "\<Plug>(neosnippet_expand_or_jump)"
            \: "\<TAB>"

" <C-h>, <BS>: close popup and delete backword char.
inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"

" <C-n>: 
inoremap <expr><C-n> pumvisible() ? "\<C-n>" : "\<C-x>\<C-u>\<C-p>\<Down>"
" <C-p>: keyword completion.
inoremap <expr><C-p> pumvisible() ? "\<C-p>" : "\<C-p>\<C-n>"

inoremap <expr>'  pumvisible() ? neocomplete() : "'"
inoremap <expr><C-x><C-f> neocomplete#start_manual_complete('file')

" <CR>: close popup and save indent.
inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
function! s:my_cr_function()
    return pumvisible() ? neocomplete#close_popup() : "\<CR>"
endfunction

function! s:check_back_space() "{{{
    let col = col('.') - 1
    return !col || getline('.')[col - 1] =~ '\s'
endfunction "}}}

" <S-TAB>: completion back.
inoremap <expr><S-TAB>  pumvisible() ? "\<C-p>" : "\<C-h>"
inoremap <expr><s-CR> pumvisible() ? neocomplete#close_popup() "\<CR>" : "\<CR>"

" }}}3

" syntastic {{{2
let g:syntastic_auto_loc_list=1
let g:syntastic_mode_map = { 'mode': 'active',
            \ 'passive_filetypes': ['c', 'cpp', 'python'] }
let g:syntastic_cpp_compiler_options=' -std=c++11 -Wall -Wextra'
let g:syntastic_cpp_config_file = '.__config'

nnoremap <silent> <Leader>sk :SyntasticCheck<CR>

" Command-T {{{2
let g:CommandTMaxHeight = 20
nnoremap <silent> <Leader>ff :CommandT<CR>
nnoremap <silent> <Leader>bb :CommandTBuffer<CR>

" MiniBufExplorer {{{2
"let g:miniBufExplVSplit=25
let g:miniBufExplorerMoreThanOne=0
let g:miniBufExplUseSingleClick=1

" ShowFunc.vim {{{2
"map <F7> <Plug>ShowFunc
"map! <F7> <Plug>ShowFunc

" ctags.vim {{{2
"let g:ctags_statusline=1
"let g:ctags_title=1
"let generate_tags=1
"
" Indent Guides {{{2
nmap <silent> <leader>ig <Plug>IndentGuidesToggle
"let g:indent_guides_enable_on_vim_startup = 1
let g:indent_guides_guide_size = 1
let g:indent_guides_start_level = 2
let g:indent_guides_auto_colors = 0
autocmd VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=red   ctermbg=95
autocmd VimEnter,Colorscheme * :hi IndentGuidesEven guibg=green ctermbg=150

" powerline {{{2
"let g:Powerline_cache_enabled=0
"let g:Powerline_theme = 'skwp'
let g:Powerline_stl_path_style = 'full'

"if !has('gui_running')
"set ttimeoutlen=10
"augroup FastEscape
"autocmd!
"autocmd InsertEnter * set timeoutlen=0
"autocmd InsertLeave * set timeoutlen=1000
"augroup END
"endif
set noshowmode


" lusty {{{2
",lj ,lf, lb
nmap <silent> <leader>j :LustyJuggler<CR>

" yankring {{{2
let g:yankring_history_dir='~/.vim_tmp'
nnoremap <Leader>r :YRShow<CR>

" vim-markdown {{{2
let g:vim_markdown_folding_disabled=1

" vim git gutter
let g:gitgutter_enabled = 0
let g:gitgutter_escape_grep = 1
let g:gitgutter_realtime = 0
"let g:gitgutter_eager = 0
nmap <leader>gt :GitGutterToggle<CR>

" }}}1

" Use local vimrc if available {{{1
if filereadable(expand("~/.vimrc.local"))
    source ~/.vimrc.local
endif
" }}}1
